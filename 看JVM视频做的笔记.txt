1.JVM概述和类加载器
    1.JVM是运行在操作系统之上的，与硬件没有直接的交互。
    2.类加载器（Classloader）将编译好的A.class文件加载到JVM的方法区中，并生成A的Class对象。类加载器只负责加载，至于能不能运行，由执行引擎决定。
        加载到JVM中后，由执行引擎来执行并输出结果。
    3.JVM调优实际上就是对方法区和堆内存进行调优。
    4.类加载器
        1.Bootstrap:启动类加载器（rt.jar），用C++实现的。
        2.Extension:拓展类加载器(ext/*.jar)。用java实现的，它用于装载Java运行环境扩展包中的类
        3.System、AppClassLoader:引用程序类加载器，也叫系统类加载器，加载当前应用的classpath下的类。

          以上三个都是虚拟机自带的加载器，用户也可以自定义加载器。要求是java.lang.ClassLoader的子类。
    4.双亲委派模型：当一个类收到了加载的请求时，它首先不会去尝试加载这个类，而是把这个请求委派给自己的父类去加载。
                    每一个层级的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。
                    只有当父类加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有这个类）子加载器才会去尝试加载这个类。
           好处：可以防止用户自己编写的类与java本身自带的类同名对程序造成破坏。比如自己编写一个java.lang.Object类

2.本地方法栈：登记本地方法，在执行引擎执行时会加载本地方法库。
        方法为native时会进入到本地方法栈执行，我们自己编写的方法时进入到java栈执行。

3.程序计数器：每个线程都有一个程序计数器，是线程私有的。

4.方法区：静态常量、类变量、类的信息（构造方法\接口定义）和运行时常量池定义在方法区。
        但是实例变量存储在堆中，与方法区无关。

