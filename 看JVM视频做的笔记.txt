1.JVM概述和类加载器
    1.JVM是运行在操作系统之上的，与硬件没有直接的交互。
    2.类加载器（Classloader）将编译好的A.class文件加载到JVM的方法区中，并生成A的Class对象。类加载器只负责加载，至于能不能运行，由执行引擎决定。
        加载到JVM中后，由执行引擎来执行并输出结果。
    3.JVM调优实际上就是对方法区和堆内存进行调优。
    4.类加载器
        1.Bootstrap:启动类加载器（rt.jar），用C++实现的。
        2.Extension:拓展类加载器(ext/*.jar)。用java实现的，它用于装载Java运行环境扩展包中的类
        3.System、AppClassLoader:引用程序类加载器，也叫系统类加载器，加载当前应用的classpath下的类。

          以上三个都是虚拟机自带的加载器，用户也可以自定义加载器。要求是java.lang.ClassLoader的子类。
    4.双亲委派模型：当一个类收到了加载的请求时，它首先不会去尝试加载这个类，而是把这个请求委派给自己的父类去加载。
                    每一个层级的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。
                    只有当父类加载器反馈自己无法完成这个加载请求时（它的搜索范围内没有这个类）子加载器才会去尝试加载这个类。
           好处：可以防止用户自己编写的类与java本身自带的类同名对程序造成破坏。比如自己编写一个java.lang.Object类

2.本地方法栈：登记本地方法，在执行引擎执行时会加载本地方法库。
        方法为native时会进入到本地方法栈执行，我们自己编写的方法时进入到java栈执行。

3.程序计数器：每个线程都有一个程序计数器，是线程私有的。

4.方法区：静态常量、常量、类变量、类的信息（构造方法\接口定义）和运行时常量池定义在方法区。
        但是实例变量存储在堆中，与方法区无关。

5.java栈：线程私有，每一个线程都有一个栈，每调用一个方法都会压入一个栈帧，最上面的栈帧称为当前栈帧，
        栈里面保存着局部变量表，操作数栈，动态链接，方法返回地址信息。

     栈、堆、方法区的交互关系:HotSpot是使用指针的方式来访问对象，Java堆会存放访问类元数据的地址，reference存储的就直接是对象的地址。

6.堆：堆分为新生代和老年代，新生代又分为eden空间和两个survior空间。
    java8及以后永久带被去除了，常量池存放在元空间。

7.垃圾回收：
        FULL GC\Major GC：老年代GC
        Minor GC：年轻代GC
8.堆内存调优：
    调优就是对方法区和堆内存进行调优，使用dump进行堆内存快照分析。

    OOM一定是由于FULL GC失败了导致的。因为首先进行GC（Minor GC），Minor GC后第一次没死的对象由eden空间进入到survior空间，计数为1，
    当该对象计数到15（默认15）后，会进入到老年代，老年代内内存溢出了就会出现OOM

    -Xmx = 堆内存 = 新生代的容量 + 老年代的容量 = TOTAL_MEMORY(虚拟机中的内存总量)

    物理内存：就是自己电脑的内存（4G、8G或16G等）
    -Xmx：虚拟机的最大分配内存，默认为物理内存的1/4
    -Xms:虚拟机分配的初始化内存，默认为物理内存的1/16
9.GC算法

    Minor GC会把Eden中所有活的对象都移到Survior区域中，如果Survior区域放不下，那么剩下的对象就被移到老年代，也即一旦收集后，Eden空间就变成空的了。

    1.判断对象是否死亡的算法：
        1.引用计数算法：不能解决循环引用的问题，已经不再使用
        2.可达性分析算法：GC Root
    2.垃圾回收算法
        1.复制算法：年轻代（主要是eden空间）使用的是复制算法，因为年轻代对象垃圾回收频繁，
            年轻代内存分为Eden空间和两个Survior空间，每次只使用Eden空间和其中一个survior空间。当回收时，将Eden和Survior中还活着的对象一次性的复制到另一块survior中，
            最后清理掉使用过得Eden空间和使用过得survior空间，并将对象年龄加1，年龄到以一定次数（默认15次，可以自己设置）之后就会进入到老年代中，如果另一块survior空间不够存放上一次新生代收集之后或者的对象，那么这些对象直接通过分配担保机制进入到老年代。
            复制算法会造成10%空间的浪费（因为默认是Eden:s0:s1 = :8:1:1）。
            复制之后有交换，谁空谁是to：from空间和to空间会交替使用（将有存活对象的survior空间复制到另一块空间）。

            优点：没有标记和清除的过程，效率高。且不会产生内存碎片
            缺点：会造成10%空间的浪费；要求对象存活率低；

         2.还有标记清除算法，标记整理算法，分代收集算法。


