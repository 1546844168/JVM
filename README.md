第2章：java内存模型和内存溢出异常

    1.运行时数据区域
        1.程序计数器：线程私有
        2.java虚拟机栈：线程私有，虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个
                方法从调用到执行完成的过程中，就对应这一个栈帧在虚拟机中入栈到出栈的过程。
            局部变量表：存放了编译器可知的8大基本类型和应用类型,其中Long和double是64位的，会占用两个局部变量空间，其余的数据类型只会占用一个。
            两种异常情况：1.线程请求的栈深度大于虚拟机所允许的深度将抛出 StackOverflowError异常
                            2.虚拟机栈可以动态扩展，如果扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常。
        3.堆内存：线程共享，在虚拟机启动时创建。几乎所有的对象实例和数组都要在堆上分配。
            内存回收：现在基本都采用分代收集算法，细分为新生代，老年代；
            堆内存：需完成实例分配，可扩展。
        4.方法区：线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
            方法区的内存回收主要是常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
        5.运行时常量池：方法区的一部分。常量池用于编译期生成的各种字面量和符号引用，在类加载后进入方法区的运行时常量池存放。
        6.直接内存：并不属于java的内存模型，但是被频繁的使用。
    2.虚拟机对象探秘
        1.对象的创建：虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。
                     加载完成后，就会分配内存。分配内存方式有两种：1.java堆如果是完整的，已使用的内存放一块，空闲的内存放一块，通过指针碰撞分配；2.java堆不是完整的，已使用的内存和未使用的内存交错，通过空闲列表的方法分配内存。
                     内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在java代码中可以不赋初值就可以直接使用。程序能访问到这些字段你的数据类型所对应的零值。
                     接下来，对对象进行必要的设置。至此，对虚拟机来说一个新的对象就已经产生了。但是对java程序来说对象创建才刚刚开始。因为<init>方法还没有执行。
        2.对象的内存布局：对象在内存中存储的布局可分为3块区域：对象头，实例数据和对齐填充。
            对象头：包含两部分信息。第一部分用于存储对象自身的运行时数据。如哈希码，GC分代年龄，锁等等；另一部分是类型指针，即对象指向它的元数据的指针，虚拟机通过这个对象来确定这个对象是哪个类的实例。
            实例数据：存储对象真正的有效信息，也就是在程序代码中定义的各种类型的字段内容。包括父类和子类。存储顺序受到虚拟机分配策略参数和字段在java中定义顺序的影响。
            对齐填充：不是必然存在的，仅仅起着占位符的作用。
        3.对象的访问定位：reference类型规定了一个指向对象的引用，这个引用有两种方式去定位对象。1.句柄；2.直接指针；
    3.OutOfMemoryError异常实战
        1.java堆溢出
            1.如果将-Xms 和 -Xmx设置为一样，可避免堆自动扩展。-Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError：用于堆转储快照文件分析
        2.虚拟机栈和本地方法栈溢出
            1.栈容量由 -Xss设置，
                如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
                如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
            2.操作系统非配给每个进程的内存室友限制的。
        3.方法区和运行时常量池溢出
            1.String.intern()：如果字符串常量池已经包含了一个等于此String对象的字符串，则返回常量池中这个字符串的String对象。
                                否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。   
            2.方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述，方法描述。
                运行时产生大量的类去填满方法区，可导致方法区溢出。
                
第三章：垃圾收集器与内存分配策略

    1.程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。这几个区域不用过多考虑垃圾回收，因为线程或方法执行结束，内存自然也就跟着回收了。
          垃圾收集器关注的是堆内存和方法区。
    2.对象已死吗？
        1.引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器器就加1；当引用失效时，计数器值就减1；计数器为0的对象就是不会再使用的。
        2.可达性分析算法：GC Root作为起始点，搜索所走过的路径称为引用链。当GC Root到这个对象不可达时，则证明这个对象是无用的了。
        3.JDK1.2以前，引用的定义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。
          JDK1.2以后，将引用分为强引用，软引用，弱引用，虚引用；引用强度依次减弱。
            1.强引用：只要强引用还存在，对象就永远不会被回收。
            2.软引用：内存溢出之前进行回收。可通过SoftReference类来实现
            3.弱引用：在垃圾收集器工作时，无论内存空间是否够，对象都会被回收掉。可通过WeakReference类来实现
            4.虚引用：无法通过虚引用来获取一个对象实例，为一个对象设置虚引用的目的就是这个对象被垃圾收集时收到一个系统通知。可通过PhantomReference来来实现虚引用。
        4.要真正宣告一个对象是否死亡，至少要经历两次标记过程。    
            如果发现对象在进行可达性分析后没有与GC Root相连接的引用链，那么进行第一次标记。
            然后在调用finalize()，可以复写finalize()方法来重新连接引用链，所以说finalize()方法是对象逃脱死亡命运的最后一次机会。
                注意：finalize()只会被系统自动调用一次。
             但是最好是不要使用finalize()，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。所以笔者建议可以忘掉这个方法的存在。
        5.在堆中，尤其是在新生代中，进行一次垃圾收集一般可以收集70% ~ 95%的空间。而永久带的垃圾收集远低于此。
    3.垃圾收集算法
        1.标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
            标记-清除算法有两个问题：1.标记和清除的效率不高
                                    2.标记清除之后会产生大量的内存碎片。碎片太多可能会导致以后无法找到足够的连续的内存而不得不提前出发另一次垃圾收集动作。
        2.复制算法：将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存使用完了，就讲存活的对象复制到另一块内存上去，在把已使用过的内存空间一次清理掉。
                     代价是将内存缩小为原来的一半。
        3.标记-整理算法：标记过程和标记-清除算法一样，然后让所有存活的对象都想一端移动，然后直接清理掉端边界以外的内存。
        4.分代收集算法：当前商业虚拟机都采用该算法。根据对象存活周期的不同将内存划分为几块。一般将java堆划分为新生代和老年代。根据各个年代的特点来采用不同的垃圾收集算法。
                        新生代采用复制算法（清除掉大量对象，只有少量存活）
                        老年代(对象存活率高)采用标记-清除或标记-整理算法。
    4.hotspot的算法实现：虚拟机如何发起内存回收
        1.枚举根节点：
        2.安全点：
        3.安全区域：
    5.垃圾收集器：
        1.serial收集器：单线程收集器，该线程运行时会暂停其他的工作线程，直至它工作结束。此线程由虚拟机后台自动发起和自动完成。     
                        特点：简单高效，是虚拟机默认的新生代收集器。
        2.parnew收集器：并行收集器，作用同serial收集器一样，多条垃圾收集线程同时执行，但用户线程还是处于等待状态。
        3.parallel scavengal收集器：目的是达到一个可控制的吞吐量
                停顿时间越短就越需要与用户交互的程序，良好的相应速度能提高用户体验，而高吞吐量则可以高效率的利用CPU时间,主要适合做后台运算而不需要太多交互的程序。
                                    吞吐量 = 运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)
        4.serial old收集器：serial收集器的老年代版本，使用标记-整理算法
        5.parallel old收集器：parallel scavengal收集器的老年代版本，使用标记-整理算法
        6.cms收集器：目的是尽可能缩短垃圾收集时用户线程的暂停时间，基于标记-清除算法。
        7.g1收集器：
        8.理解GC日志：
        9.垃圾收集器各大参数总结：见P112
    6.内存非配与回收策略
           给对象非配内存以及回收分配给对象的内存
        1.对象优先在Eden分配：当Eden区没有足够的空间进行非配时，虚拟机将发生一次Minor GC,若GC期间发现已有的对象全部无法放入Survovir空间，将通过非配担保机制提前转移到老年代中。
                示例中的VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
            Minor GC:指发生在新生代的垃圾收集动作,Minor GC非常频繁，回收速度快
            Full GC/Major GC:指发生在老年代的GC,Major GC一般会比Minor GC慢10倍以上
        2.大对象直接进入老年代：所谓的大对象就是指那些需要大量连续内存空间的java对象，典型的大对象就是很长的字符串和数组
                      -XX:PretenureSizeThreshold=3145728:大于这个设置值得对象直接在老年代分配，避免在Eden区和Survivor之间发生大量的内存复制，因为新生代采用复制算法收集内存。
        
        3.长期存活的对象将进入老年代：虚拟机采用分代收集的思想来收集内存，虚拟机给每个对象设置了一个年龄计数器.....。
        4.
        
        
        
        
        
第八章：虚拟机字节码执行引擎

    1.概述
    2.运行时栈帧结构
        1.局部变量表：。。。。。。在编译为Class文件的时候就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。
                    局部变量表建立在贤臣的堆栈上，是线程私有的数据。无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。   
                    long和double并不是原子操作。Slot复用会影响到垃圾回收、局部变量需要手动赋予初始值。
                    谨记：不适用的对象手动设置为null。
        2.操作数栈：
        3.动态连接：
        4.方法返回地址：当一个方法运行时，只有两种方式可以退出这份方法。
            1.第一种方式是执行引擎遇到任意一个方法返回的字节码指令，
            2.第二种方式是遇到异常，且这个异常在方法体内没有处理。
    3.方法调用：方法调用就是确认调用哪一个方法，暂时不设计方法内部的具体运行过程。
                Class文件的编译过程不包括传统编译的连接步骤，一切方法调用在Class文件中存储的都知识符号引用。
                这个特性个java带来了跟家强劲的动态扩展能力
        1.解析：调用目标在程序代码写好，编译器进行吧编译时就必须确认下来。
        2.分派
            Fu a = new Zi();
            1.静态分派：静态类型(Fu)编译时就可知，而实际类型(Zi)在运行时才确定下来。
                        虚拟机（准确的来说是编译器）在重载是通过参数的静态类型而不是实际类型作为判定依据的。
            2.动态分派：运行期根据实际类型来确定方法执行版本的分派过程称为动态分派。重写就是动态分派。
      idea中的插件用不了，需要问叶剑龙。
